local ryoku_path = sys.get_save_file("ryoku", "data_level")
local config = sys.load(ryoku_path)
local list = require("ressources.listLevel")
local blockList = require("ressources.listBlocks")
local puzzle = require("construct.puzzles")
local colorList = require("construct.groupsColors")
local currentLevel = list[config.level].path
local blocksStart = blockList[currentLevel.platform.column].path

local languages = require("ressources.langages")

function initializeGrid(self)
	for c = 1, #currentLevel.groupProgress do
		currentLevel.groupProgress[c].isCompleted = false
		currentLevel.groupProgress[c].processGroup = false
		currentLevel.groupProgress[c].number = 0
		currentLevel.groupProgress[c].color = 0
	end
	for d = 1, #currentLevel.groups do
		currentLevel.groups[d].ispopulate = false
		currentLevel.groups[d].groupTarget = false
		currentLevel.groups[d].isDisplayGroup = false
		currentLevel.groups[d].animateGroup = false
		--currentLevel.groups[d].colorBrique.w = 1
	end
	currentLevel.platform.slider.isTouchSlide = false
	currentLevel.platform.slider.isSlideLeftRight = false
	currentLevel.platform.slider.dragBlock = false
	currentLevel.platform.slider.whenPoseAndReplacingBlockIsDone = false
	currentLevel.platform.slider.isBlockMatch = false
	currentLevel.platform.isDragUp = false
	currentLevel.platform.isStartSlid = false
	currentLevel.platform.initialManageTarget = false
	currentLevel.platform.actionLostLevel = false
	currentLevel.platform.indexLeftAvailable = 0
	currentLevel.platform.indexRightAvailable = 0
	currentLevel.selectionBlock[1].selectionFactoryBlockId = ""
	currentLevel.selectionBlock[2].selectionFactoryBlockId = ""
	currentLevel.selectionBlock[3].selectionFactoryBlockId = ""
	currentLevel.platform.isCollisionable = false
	currentLevel.platform.processing = false
	currentLevel.platform.slidToRight = false
	currentLevel.platform.slidToLeft = false
	currentLevel.platform.actionReleased = false
	currentLevel.platform.slider.directionSlider = 0
end

function defineDimensionNumber(currentBlock)
	local dimX = 0
	local dimY = 0

	for j = 1, #currentBlock do
		if currentBlock[j].blockX > dimX then
			dimX = currentBlock[j].blockX
		end
		if currentBlock[j].blockY > dimY then
			dimY = currentBlock[j].blockY
		end
		if #currentBlock == j then
			for k = 1, #puzzle do
				if puzzle[k].elevationX == dimX + 1 and puzzle[k].elevationY == dimY + 1 then
					return puzzle[k].number
				end
			end
		end
	end
end

function randomBlock(self)
	local blockListInsert = {}
	local refListInsert = {}

	local blockList = {}
	local refList = {}

	for i = 1, #self.fusionBlock do
		table.insert(blockList, i, self.fusionBlock[i])
	end

	math.randomseed(os.time())

	for z = 1, #self.fusionBlock do
		local hasard = math.random(1, #blockList)

		for b=1, #blockList[hasard] do
			blockList[hasard][b].blockNumber = z
			blockList[hasard][b].isPlaned = false
			blockList[hasard][b].isLocked = false
			blockList[hasard][b].isMatch = false
			blockList[hasard][b].isColored = false
			blockList[hasard][b].positionTileBlock = vmath.vector3(0, 0, 1)
			blockList[hasard][b].positionPlaned = vmath.vector3(0, 0, 1)
			blockList[hasard][b].positionReturn = vmath.vector3(0, 0, 1)
		end

		table.insert(refListInsert, {
			factoryBlockId = "",
			factoryTetrisId = "",
			blockNumber = z,
			positionBlock = vmath.vector3(0, 0, 0),
			isActive = true,
			x0 = 0,
			x1 = 0,
			y0 = 0,
			y1 = 0,
			originXY = vmath.vector3(0, 0, 0),
			index = z,
			l0 = vmath.vector3(0, 0, 0),
			l1 = vmath.vector3(0, 0, 0),
			isdisplaying = false,
			isPending = false,
			selectDimension = defineDimensionNumber(blockList[hasard])
		})
		
		table.insert(blockListInsert, blockList[hasard])
		
		table.remove(blockList, hasard)

		if #self.fusionBlock == z then
			currentLevel.blocks = blockListInsert
			currentLevel.refBlock = refListInsert
		end
	end
end
function randomChallenge(self)
	math.randomseed(os.time())
	currentLevel.platform.randomChallenge = math.random(1,#currentLevel.platform.startChallenge)
end

function randomColor(self)
	local randomGroupColor = {}
	local groupSelect = {}
	local groupProgressSelect = {}

	for i = 1, #colorList do
		table.insert(randomGroupColor, i, colorList[i])
	end

	math.randomseed(os.time())
	for z = 1, currentLevel.platform.column do
		local hasardColor = math.random(1,#randomGroupColor)
		local group = {
			ispopulate = false,
			number = z,
			counterSquares = 0,
			groupTarget = false,
			isDisplayGroup = false,
			animateGroup = false,
			groupColorId = randomGroupColor[hasardColor].id
		}
		local groupProgress = {
			isCompleted = false,
			processGroup = false,
			number = 0,
			color = 0
		}

		table.insert(groupSelect, group)
		table.insert(groupProgressSelect, groupProgress)
		table.remove(randomGroupColor, hasardColor)
		
		if z == currentLevel.platform.column then
			currentLevel.groups = groupSelect
			currentLevel.groupProgress = groupProgressSelect
		end
	end
end

function calculateRelativePositionBlock(self, nbBlock)
	local minX = 14
	local minY = 14
	for k = 1, #self.fusionBlock[nbBlock.blockNumber] do
		if self.fusionBlock[nbBlock.blockNumber][k].result.tileX < minX then
			minX = self.fusionBlock[nbBlock.blockNumber][k].result.tileX
		end
		if self.fusionBlock[nbBlock.blockNumber][k].result.tileY < minY then
			minY = self.fusionBlock[nbBlock.blockNumber][k].result.tileY
		end
		if #self.fusionBlock[nbBlock.blockNumber] == k then
			for b = 1, #self.fusionBlock[nbBlock.blockNumber] do
				self.fusionBlock[nbBlock.blockNumber][b].blockX = self.fusionBlock[nbBlock.blockNumber][b].result.tileX - minX
				self.fusionBlock[nbBlock.blockNumber][b].blockY = self.fusionBlock[nbBlock.blockNumber][b].result.tileY - minY
			end
		end
	end
end

function generateTetrisBlock(self)
	for i = 1, #blocksStart[currentLevel.platform.listBlock] do
		for j = 1, #blocksStart[currentLevel.platform.listBlock][i] do
			local nbBlock = {
				blockX = 0,
				blockY = 0,
				blockId = "",
				positionTileBlock = vmath.vector3(0, 0, 1),
				isPlaned = false,
				result = {
					tileX = j-1,
					tileY = i-1
				},
				positionPlaned = vmath.vector3(0, 0, 1),
				positionReturn= vmath.vector3(0, 0, 1),
				isColored = false,
				blockNumber = blocksStart[currentLevel.platform.listBlock][i][j],
				isLocked = false,
				isMatch = false,
				instanceId = ""
			}
			if self.fusionBlock[blocksStart[currentLevel.platform.listBlock][i][j]] == nil then
				self.fusionBlock[blocksStart[currentLevel.platform.listBlock][i][j]] = {}
			end
			table.insert(self.fusionBlock[blocksStart[currentLevel.platform.listBlock][i][j]], nbBlock)
			calculateRelativePositionBlock(self, nbBlock)
		end
	end
end

function findNumber(sudokuNumber)
	if sudokuNumber == 1 then
		return "one"
	end
	if sudokuNumber == 2 then
		return "two"
	end
	if sudokuNumber == 3 then
		return "three"
	end
	if sudokuNumber == 4 then
		return "four"
	end
	if sudokuNumber == 5 then
		return "five"
	end
	if sudokuNumber == 6 then
		return "six"
	end
	if sudokuNumber == 7 then
		return "seven"
	end
	if sudokuNumber == 8 then
		return "eight"
	end
	if sudokuNumber == 9 then
		return "nine"
	end
	if sudokuNumber == 10 then
		return "ten"
	end
	if sudokuNumber == 11 then
		return "eleven"
	end
	if sudokuNumber == 12 then
		return "twelve"
	end
end

function generateConformationGrid(self)
	for g = 1, #currentLevel.patterGrid do
		for q = 1, #currentLevel.patterGrid[g] do
			local tile = {
				positionX = q-1,
				positionY = g-1,
				color = vmath.vector4(),
				groupId = currentLevel.patterGrid[g][q][2],
				instanceId = "",
				xy = vmath.vector3(),
				gdXY = vmath.vector3(),
				isGrey = false,
				number = findNumber(currentLevel.patterGrid[g][q][1]),
				ispopulate = false,
				isGood = false,
				isPendingGood = false,
				instanceSquareId = "",
				target = false,
				revealed = false,
				groupLocked = false,
				conformationName = "SIMPLE",
				blockNumber = 0,
				gridId = "",
				gridSpriteId = "",
				animateGroup = false,
				x0 = vmath.vector3(),
				x1 = vmath.vector3(),
				y0 = vmath.vector3(),
				y1 = vmath.vector3(),
				revelatedAdjacentBonus = false,
				urlBorderGroup = "",
				conformationBorderGroup = "",
				blockEntryInTile = false,
				isCollisionable = false
			}
			if self.conformationGrid[g] == nil then
				self.conformationGrid[g] = {}
			end
			table.insert(self.conformationGrid[g], tile)
			if #currentLevel.patterGrid == g and #currentLevel.patterGrid[g] == q then
				currentLevel.grid = self.conformationGrid
			end
		end
	end
end

function init(self)
	if config.game_language  == "ru" or config.game_language  == "be" then
		gui.set_font(gui.get_node("number_level"), hash("RU_30_border"))
		gui.set_font(gui.get_node("start"), hash("RU_85_border"))
	end
	if config.game_language  == "ar" then
		gui.set_font(gui.get_node("number_level"), hash("ARB_35_border"))
		gui.set_font(gui.get_node("start"), hash("ARB_80_border"))
	end
	if config.game_language  == "ja" then
		gui.set_font(gui.get_node("number_level"), hash("JA_30_border"))
		gui.set_font(gui.get_node("start"), hash("JA_80_border"))
	end
	if config.game_language  == "ko" then
		gui.set_font(gui.get_node("number_level"), hash("KR_30_border"))
		gui.set_font(gui.get_node("start"), hash("KR_80_border"))
	end
	if config.game_language  == "vi" then
		gui.set_font(gui.get_node("number_level"), hash("VI_30_border"))
		gui.set_font(gui.get_node("start"), hash("VI_80_border"))
	end
	msg.post("@render:", "clear_color", { color = vmath.vector4(0.949, 0.952, 0.956, 0) })
	msg.post(".", "acquire_input_focus")
	local label_level = languages[config.game_language].label_indicator_level.."#"..config.level
	gui.set_text(gui.get_node("number_level"), label_level)
	gui.set_text(gui.get_node("start"), languages[config.game_language].label_start_level)
	randomChallenge(self)
	self.fusionBlock = {}
	self.conformationGrid = {}
	currentLevel.blocks = {}
	currentLevel.refBlock = {}
	currentLevel.grid = {}
	generateConformationGrid(self)
	generateTetrisBlock(self)
	initializeGrid(self)
	randomBlock(self)
	randomColor(self)
	if config.level == 3 and not config.enable_adjacent then
		currentLevel.platform.stopGame = true
	end
	if config.level == 4 and not config.enable_target then
		currentLevel.platform.stopGame = true
	end
	if config.level == 5 and not config.enable_group then
		currentLevel.platform.stopGame = true
	end
end

function final(self)
	-- Add finalization code here
	-- Learn more: https://defold.com/manuals/script/
	-- Remove this function if not needed
end

function update(self, dt)
	-- Add update code here
	-- Learn more: https://defold.com/manuals/script/
	-- Remove this function if not needed
end

function on_message(self, message_id, message, sender)
	-- Add message-handling code here
	-- Learn more: https://defold.com/manuals/message-passing/
	-- Remove this function if not needed
end

function on_input(self, action_id, action)
	if action_id == hash("touch") and action.pressed then
		if gui.pick_node(gui.get_node(hash("start_level")), action.x, action.y) then
			msg.post("controller:/loader#controller", "changeScene", { newScene = "playLevel" })
		end
	end
end

function on_reload(self)
	-- Add reload-handling code here
	-- Learn more: https://defold.com/manuals/hot-reload/
	-- Remove this function if not needed
end
